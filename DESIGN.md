I started implementing my project by envisioning the battle algorithm I would end up using. After evaluating many different possibilities, I decided to use one that had both a static component and a dynamic component. The static component is the
simulateBattle() method of the Battle class. What this method does is simulate fighting over sustained period of times using information about the different units each army has (their properties such as "charge" strength, "skirmish" strength, and the number of units there are of that type in that army.) This method also uses certain modifiers that affect the calculated values for important changes such how much of a unit is lost over a certain period of time and how much morale an army loses over a certain period of time. While these values were arbitrary at first, I repeatedly tested different values to finally achieve values that I believe suited the game well. Currently, the modifiers and the calculations they influence lend themselves to different outcomes, influenced primarily by the choices made by the user. This is likely the most pivotal part of my game, the fact that the decisions made by the user have the potential of influencing the outcome of battles, and this was also the hardest part of the implementation as it required continous testing with small adjustments each time.

In terms of the general organization of the project, I used two classes, from which I instanced objects in the main.lua file. These classes are the Battle and Army classes. The battle class handles the rendering of the graphics during each battle scene, and it also handles prompting the user for 3-4 times each battle with a certain time interval. Along with prompting the user, it also handles processing the choices made by the user and reflecting the outcomes onto the properties stored in the instanced object, which are then reflected onto the screen by render methods for the user to follow. In my main.lua file, I complete the necessary setup, which includes the screen setup, setting up media resources, declaring important global variables such as a state tracker and other tracking variables with similar purposes, and defining relevant global functions. Also, the different game states are handled within the main update() function in main.lua, and the graphics that accompany each game state are rendered from the main draw() function (that calls the render methods that I defined), again situated in main.lua. The keypressed() function that comes with Love (similar to update and draw) also responds differently according to the current game state, and it is the primary way in which the program responds to user input. Among the project files is also the class.lua file, written by Matthias Richter, that simplifies the use of classes and thereby makes object-oriented programming in Lua easier.